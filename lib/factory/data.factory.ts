import { Type } from '@nestjs/common';
import { Factory, PropertyMetadata } from '../interfaces';
import { FactoryValue } from '../decorators/factory.decorator';
import { FactoryMetadataStorage } from '../storages/factory.metadata.storage';
import * as faker from 'faker';

export class DataFactory {
  static createForClass(target: Type<unknown>): Factory {
    if (!target) {
      throw new Error(
        `Target class "${target}" passed in to the "TemplateFactory#createForClass()" method is "undefined".`,
      );
    }

    const properties = FactoryMetadataStorage.getPropertyMetadatasByTarget(
      target,
    );

    return {
      generate: <T = void>(count: number, context?: T): Record<string, FactoryValue>[] => {
        const ret = Array<Record<string, FactoryValue>>();
        for (let i = 0; i < count; i++) {
          ret.push(this.generate<T>(properties, context));
        }
        return ret;
      },
    };
  }

  private static generate<T = void>(
    properties: PropertyMetadata<T>[],
    context?: T
  ): Record<string, FactoryValue> {
    return properties.reduce(
      (r, p) => {
        // the values generated by the factory
        const factoryIntermediate = typeof p.arg === 'function' ? p.arg(faker, context) : null
        // the final value put in the object
        const factoryValue = factoryIntermediate ?? p.arg;
        // reassign the context with the new values
        context = { 
          ...context, 
          ...(factoryIntermediate ?? {}),
          [p.propertyKey]: factoryValue,
        };

        return {
          [p.propertyKey]: factoryValue,
          ...r,
        }
      },
      {},
    );
  }
}
